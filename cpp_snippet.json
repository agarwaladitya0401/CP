{
	"Default cpp formate": {
		"prefix": [
			"include",
			"default"
		],
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"#define endl \"\\n\" ",
			"#define int long long",
			"#define ll long long",
			"#define pi (3.141592653589)",
			"#define mod 1000000007",
			"#define float double",
			"#define pb push_back",
			"#define mp make_pair",
			"#define ff first",
			"#define ss second",
			"#define all(c) c.begin(), c.end()",
			"#define min3(a, b, c) min(c, min(a, b))",
			"#define min4(a, b, c, d) min(d, min(c, min(a, b)))",
			"#define rfo(i,a,b) for(int i=(int)a;i>=(int)b;i--)",
			"#define fo(i,a,b) for(int i=(int)a;i<(int)b;i++)",
			"#define watch(x) cout << (#x) << \" is \" << (x) << endl",
			"#define see(x) cout << (x) << endl",
			"#define hh cout << endl",
			"#define INF 1e18",
			"#define fast ios_base::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);",
			"\n",
			"template<typename C,",
			"typename T = std::decay_t<decltype(*begin(std::declval<C>()))>,",
			"typename std::enable_if<!std::is_same<C, std::string>::value>::type* = nullptr>",
			"std::ostream &operator<<(std::ostream &os, const C &container){",
			"bool first = true;",
			"std::stringstream ss; ",
			"ss << '[';",
			"	for(const auto &x : container){",
			"		if (!first){",
			"			ss << \", \";",
			"		}",
			"		first = false;",
			"		ss << x;",
			"	}",
			"	ss << ']';",
			"	return os << ss.str();",
			"}",
			"template<class T1, class T2>",
			"std::ostream &operator<<(std::ostream &os, const std::pair<T1,T2> &p){",
			"	os << '{' << p.first << \", \" << p.second << '}';",
			"	return os;",
			"}\n",
			"ll mod_pow ( ll a , ll b )",
			"{",
			"	if ( b < 0 ) return 0 ;",
			"	a %= mod ;",
			"if ( b == 0 ) return 1 ;",
			"if ( b == 1 ) return a%mod ;",
			"if ( b == 2 ) return ((a%mod)*(a%mod))%mod ;",
			"return ( mod_pow ( mod_pow ( a,b/2 ) , 2 ) * mod_pow ( a , b%2 ) ) % mod ;",
			"}\n",
			"bool isPrime(int n){",
			"	if(n==1) return false;",
			"	if(n==2) return true;",
			"	for(int i=2;i*i<=n;i++){",
			"		if(n%i==0)return false;",
			"	}",
			
			"	return true;",
			"}\n",
			"// Keep calm and Keep coding //\n\n\n\n\n",
			"void solve()",
			"{",
			"	int n,m;",
			"	cin>>n;",
			"	$0",
			"return;",
			"}\n\n",
			"int32_t main(){",
			"fast",
			"int tc=1;",
			"cin>>tc;",
			"while(tc--){",
			"	solve();"
			"}",
			"return 0;",
			"}",
			"",
		],
		"description": "This is a c++ sniffpet",
	},
	"for loop": {
		"prefix": "forl",
		"body": [
			"for($1 $2 = $3 ; $2 < $4 ; $2++)",
			"{","	${0:/* code */}",
			"}"
		],
		"description": "For Loop"
	},
	"segmemt tree": {
		"prefix": "segment tree",
		"body": [
			"const int N = 1e5 + 5;",
			"const int INF = 1e9;",
			" ",
			" ",
			"/*",
			"KEYNOTES:",
			"------------------------------------------",
			"merge(X,identity_element) = X",
			"------------------------------------------",
			"------------------------------------------",
			"identity_transformation.combine(X) = X",
			"------------------------------------------",
			"------------------------------------------",
			"ALWAYS: older_update.combine(newer_update)",
			"------------------------------------------",
			"*/",
			" ",
			" ",
			" ",
			"// example: addition: identity element is 0",
			" ",
			"// a + 0 = a or 0 + a = a",
			" ",
			"// min(x,INF) = x",
			" ",
			"struct my_node",
			"{",
    "	int mn = INF;",
    "	int freq = 0;",
    "	// use more variables if you want more information",
    "	// these default values should be identity_element",
    "	my_node(){}",
    "	my_node(int val){",
    "		mn = val;",
    "		freq = 1;",
    "	}",
    "	void merge(const my_node &l,const my_node &r){ // store the thing you wanna query",
			" ",
    "		mn = min(l.mn,r.mn);",
    "		freq = 0;",
    "		if(l.mn == mn) freq += l.freq;",
    "		if(r.mn == mn) freq += r.freq;",
			" ",
    "		// if we wanted the maximum, then we would do",
    "		// like v = max(l.v,r.v)",
    "	}",
			"};",
			" ",
			"// example: add on a range: identity transformation = 0",
			"// old += new",
			" ",
			"// if old is identity which is 0, then 0 + new which new",
			" ",
			"struct my_update",
			"{",
    "	int v = 0; // 4",
    "	// use more variables if you want more information",
    "	// these default values should be identity_transformation",
    "	my_update(){}",
    "	my_update(int val){",
    "		v = val; // 5",
    "	}",
    "	// combine the current my_update with the other my_update (see keynotes)",
    "	void combine(my_update &other,const int32_t &tl,const int32_t &tr){",
    "		v += other.v; // 6",
			" ",
    "		// you can be sure that the \"other\" is newer than current",
			" ",
    "	}",
    "	// store the correct information in the my_node x",
    "	void apply(my_node &x,const int32_t &tl,const int32_t &tr){",
			" ",
    "		// no change in freq",
    "		x.mn += v;",
			" ",
    "	}",
			"};",
			" ",
			"template<typename node,typename update>",
			"struct segtree",
			"{",
    "	int len;",
    "	vector<node> t;",
    "	vector<update> u;",
    "	vector<bool> lazy;",
    "	node identity_element;",
    "	update identity_transformation;",
    "	segtree(int l){",
    "		len = l;",
    "		t.resize(4 * len);",
    "		u.resize(4 * len);",
    "		lazy.resize(4 * len);",
    "		identity_element = node();",
    "		identity_transformation = update();",
    "	}",
			" ",
    "	void pushdown(const int32_t &v, const int32_t &tl, const int32_t &tr){",
    "		if(!lazy[v]) return;",
    "		int32_t tm = (tl + tr) >> 1;",
    "		apply(v<<1,tl,tm,u[v]);",
    "		apply(v<<1|1,tm+1,tr,u[v]);",
    "		u[v] = identity_transformation;",
    "		lazy[v] = 0;",
    "	}",
			" ",
    "	void apply(const int32_t &v, const int32_t &tl, const int32_t &tr, update upd){",
    "		if(tl != tr){",
    "			lazy[v] = 1;",
    "			u[v].combine(upd,tl,tr);",
    "		}",
    "		upd.apply(t[v],tl,tr);",
    "	}",
			" ",
    "	template<typename T>",
    "	void build(const T &arr,const int32_t &v, const int32_t &tl, const int32_t &tr){",
    "		if(tl == tr){",
    "			t[v] = arr[tl];",
    "			return;",
    "		}",
    "		int32_t tm = (tl + tr) >> 1;",
    "		build(arr,v<<1,tl,tm);",
    "		build(arr,v<<1|1,tm+1,tr);",
    "		t[v].merge(t[v<<1],t[v<<1|1]);",
    "	}",
			" ",
    "	node query(const int32_t &v,const int32_t &tl,const int32_t &tr,const int32_t &l,const int32_t &r){",
    "		if(l > tr || r < tl){",
    "			return identity_element;",
    "		}",
    "		if(tl >= l && tr <= r){",
    "			return t[v];",
    "		}",
    "		pushdown(v,tl,tr);",
    "		int32_t tm = (tl + tr) >> 1;",
    "		node a = query(v<<1,tl,tm,l,r),b = query(v<<1|1,tm+1,tr,l,r),ans;",
    "		ans.merge(a,b);",
    "		return ans;",
    "	}",
			" ",
    "	// rupd = range update",
    "	void rupd(const int32_t &v,const int32_t &tl,const int32_t &tr,const int32_t &l,const int32_t &r,const update &upd){",
    "		if(l > tr || r < tl){",
    "			return;",
    "		}",
    "		if(tl >= l && tr <= r){",
    "			apply(v,tl,tr,upd);",
    "			return;",
    "		}",
    "		pushdown(v,tl,tr);",
    "		int32_t tm = (tl + tr) >> 1;",
    "		rupd(v<<1,tl,tm,l,r,upd);",
    "		rupd(v<<1|1,tm+1,tr,l,r,upd);",
    "		t[v].merge(t[v<<1],t[v<<1|1]);",
    "	}",
			" ",
    "	public:",
    "	template<typename T>",
    "	void build(const T &arr){",
    "		build(arr,1,0,len-1);",
    "	}",
    "	node query(const int32_t &l,const int32_t &r){",
    "		return query(1,0,len-1,l,r);",
    "	}",
    "	void rupd(const int32_t &l,const int32_t &r,const update &upd){",
    "		rupd(1,0,len-1,l,r,upd);",
    "	}",
			"};",
			" ",
			"int main(){",
			" ",
    "	segtree<my_node,my_update> s(1000); // create a segment tree of length 1000",
    "	vector<int> v(1000);",
			" ",
			" ",
    "	segtree<my_node2,my_update2> s2(34543);",
			" ",
    "	v[10] = 35;",
    "	v[13] = 3;",
			" ",
    "	s.build(v);",
			" ",
    "	s.rupd(2,5,8);",
			" ",
    "	s.rupd(1,3,-4);",
			" ",
    "	for(int i = 0; i < 15; i++){",
    "		cout << s.query(i,i).mn << \" \";",
    "	}",
			" ",
    "	cout <<\"\\n\\n\" << s.query(2,4).mn << \" \" << s.query(2,4).freq;",
			" ",
    "	return 0;",
			"}",
			" ",
			" ",
			" ",
			" ",
			"// how to define the behaviour or the nature of the ",
			"// updates and queries",
			" ",
			" ",
			"// this segtree was sum in range and add on range",
			" ",
			" ",
			"// let's change it to -> (sum on range) and (set all values on range)",
			" ",
			" ",
			" ",
			"// let's make the one from the question earlier",
			" ",
			"// get min element and frequency of min element on a range AND add on a range"
		],
		"description": ""
	},
	"dsu": {
  "prefix": "dsu template",
  "body": [
    "struct UF {",
    "	vector<int> e;",
    "	UF(int n) : e(n+1, -1) {}",
    "	bool sameSet(int a, int b) { return find(a) == find(b); }",
    "	int size(int x) { return -e[find(x)]; }",
    "	int find(int x) { return e[x] < 0 ? x : e[x] = find(e[x]); }",
    "	bool join(int a, int b) {",
    "		a = find(a), b = find(b);",
    "		if (a == b) return false;",
    "		if (e[a] > e[b]) swap(a, b);",
    "		e[a] += e[b]; e[b] = a;",
    "		return true;",
    "	}",
    "};"
  ],
  "description": ""
},
"clock": {
  "prefix": "clock",
  "body": [
    "using namespace std::chrono;",
    "auto start = high_resolution_clock::now();",
    "auto stop = high_resolution_clock::now();",
    "auto duration = duration_cast<microseconds>(stop - start);",
    "cout << \"Time taken by function: \"<< duration.count() << \" microseconds\" << endl;"
  ],
  "description": ""
}
}
